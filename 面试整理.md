# 面试整理

## HTML/css
* cookies，sessionStorage 和 localStorage 的区别:
`
    cookie:小,始终在同源http请求中携带
    sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
    session浏览器关闭之后删除
    
`

#### 盒模型
* 内容(content)、填充(padding)、边界(margin)、 边框(border)
* IE内容包含了border和padding,box-sizeing:border-box
* 取高度和宽度,window.getComputeStyle(dom).width/height
* dom.getBoundingClientRect().w/h
* BFC块级格式化上下文:
1. BFC不与浮动元素box重叠,清楚浮动
2. bfc内外无关联
3. bfc内元素边距会发生重叠
4. 计算高度bfc也会参与计算    
* 创建BFC
1. float
2. position
3. display:inline-block flex table
4. overflow

####  CSS3/HTML5新特性
* 常见meta标签
`
    页面关键词  <meta name="keywords" content="your tags" />
    页面描述    <meta name="description" content="150 words" />
    webapp全屏模式 <meta name="apple-mobile-web-app-capable" content="yes" />
    申明编码 <meta charset='utf-8' />
    优先使用 IE 最新版本和 Chrome
　　<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta  render = ''/>        

`
* css3新特性:
    border-radius background-size border-image  linear渐变 transfrom2d 3d旋转缩放  transition
* H5 新特性:
    localStorage(长期) sessionStorage(浏览器关闭) querySelector getElementsByClassName classList -add() -remove flex 新语义标签 article section figure
    

## Css细节问题
* 语义化:section块 artical容器
* 网格布局grid(待补充)
* 边际重叠,上下margin会重叠,办法:加一个父级创建bfc,使用overflow
* 清楚浮动原理:外层为bfc,子元素就会参与计算,overflow

## DOM  
* Dom是一种标准,dom2是addevent的方式(冒泡和捕获),dom3添加了一些事件,如键盘事件
* 事件模型:捕获,冒泡
* DOM0:element.onclick = Fn
* DOM2:element.addEventlistener('click',fn,false)
* DOM3:element.addEventListener('keyup',fn,false)
* 事件流:捕获-->目标流-->冒泡
* DOM事件捕获的具体流程:window-->document-->html(htmlElement)-->body--->父级元素
* 事件代理/委托:使用apply来实现调用对象的转移,也可以是通过dom中的父节点添加事件,在父元素事件处理函数内部判断是否是具体的某个元素触发,再执行具体命令


### event对象:
* preventdefault()阻止默认
* preventstopProgation 阻止冒泡
* stopImmediaPropagation,使用该方法可以提高优先级,并阻止剩余
* event.target指代的是:触发事件的元素
* event.currentTarget指代的是:事件绑定的元素
* 自定义事件   
`
    var ele = new Event('myevent')
    ele.addEventListener('myevent',fn)
    ele.dispatchEvent(eve)
    customEvent...和Event
` 

## JS
#### 基础问题
* 基本数据类型 undefined null string  number boolean
* 引用数据类型 function object array
* 其他内置对象 Function、Argument、Math、Date、RegExp、Error
* JS堆和栈: 
    栈：原始数据类型（Undefined，Null，Boolean，Number，String）  
    堆：引用数据类型（对象、数组、函数）
* call:call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。  (如果不指定为全局即window
####原型以及原型链
* 使用new 后的函数即构造函数
* instanceOf 判断在不在原型链上,如果判断是否直接生成,需要constructor
* JavaScript中任意对象都有一个内置属性[[prototype]]即_proto_, _proto_指向创建这个对象的函数(constructor)的prototype
* 每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。而函数也是对象所以也有_proto_
* 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就通过_proto_去prototype里找这个属性，这个prototype又有自己的_proto_又指向它构造函数的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。
* 继承: 
        `
           完美:
                function Parent(name) {
                    this.name = name;
                }
                Parent.prototype.play = function() {
                    console.log(this.name);
                }

                function Child(name, age) {
                    //这里只会继承属性,因为parent(){}里没有写prototype
                    Parent.call(this, name);
                    this.age = age;
                }
                //这样会重复调用两次构造函数,而且consturctor指向错误
                child.prototype = new Parent();
                //这样解决两次构造函数,consturctor指向错误
                child.prototype = parent.prototype 
                //最终版
                //通过原型链来实现原型属性和方法的继承,中间对象,隔离父子对象原型
                Child.prototype = Object.create(Parent.prototype);
                child.prototype = constructor = child;

                // 多态
                Child.prototype.play = function() {
                    //借用父对象构造函数
                    Parent.prototype.play.call(this);
                }
                //这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。
                var child = new Child();
        
        `
        * new之后发生的事情
        `
            (1)创建一个空对象，执行构造函数,继承该函数的原型,this引用这个对象
            (2)属性和方法被加入到 this 引用的对象中。
            (3)新创建的对象由 this 所引用，并且最后隐式的返回 this 。
            //
            var base = new Base();
            var obj = {};
            obj.__proto__ = Base.prototype;
            Base.call(obj);
        
        `


#### HTTP
   * 特点:快速,灵活,无状态,无连接 
   * 报文:请求报文(请求行,请求头,空行,请求体),响应报文(状态行,响应头,空行,响应体)
   * accept和content-type区别,accpt代表预期,希望得到的数据,content-type代表是发送的实体数据的数据类型
   * 请求行:HTTP方法(get),地址,协议，版本
   * 请求头:key,value
   * 空行:请求头结束
   * 方法:get post put delete head
   * 协议,请求头,请求体 
   * 跨域:不同地址,不同端口,不同协议,不同级别均跨域
   * get与post区别:   
   `
    get回退不会重新发送请求
    get会被主动缓存
    get参数会保留在浏览器记录里
    get有参数限制
    get明文传递
    geturl,post requestbody
   `
   * 206:range头的get请求,截取部分,（视频
   * 301:重定向,302，临时重定向,304缓存
   * 400:语法错误 403:无权限,被阻止
   * 1.1版本,keep-Live持久连接:连接后不会断开
   * 管线化:请求一次发送,响应也一次返回(只有get和Head可以进行,必须是keep-live
   * json与字符串的转化:
   JSON.parse(data)//json字符串变对象
   JSON.stringfiy//对象转成序列化字符串

   * ajax: new - open(参数) - send() - onload(200&&400) - error 
    `
         var request = new XMLHttpRequest();
        request.open('GET', '/my/url', true);

        request.onload = function() {
        if (request.status >= 200 && request.status < 400) {
            // Success!
            var data = JSON.parse(request.responseText);
        } else {
            // We reached our target server, but it returned an error

        }
        };

        request.onerror = function() {
        // There was a connection error of some sort
        };

        request.send();
    `
    * ajax post: new open(post) setRequestHeader('content-type',applocation/x-www-form-urlencoded) --onload --send(data)

#### fetch (cros)
* 自带promise,fetch(
        url,{
            method:'',headers:{'content-type':'xxxx'},body:'',cros:acrosxxx
        }).then().then(function(data){}).catch
#### websokit
* 不受跨域限制
#### cros
* 
#### 跨域
* jsonp,Hash(#后面),websockt,postmessage(h5),cors请求头令牌跨域
* 关于jsonp:创建一个script标签,请求后端文件,并和后端约定好回调名,后端返回数据和函数,然后执行script标签中约定好的函数,然后删除标签
* hash: window.onhashChange,window.location.hash
* postmessage window.potmessage('data','url'),addEventLienter('message){event.origin,event.source,enent.data}
* websockt: new websockt('dizhi')
#### 数组操作:
##### 重要的数组操作:
* isArray:判断数组
* from(arrLike,mapFn):将任何有length属性的对象转为数组
* push(返回长度),pop(返回该元素) 
* unshift(从前插入,返回长度),shift(返回元素)
* reverse:反转顺序
* arr.sort((a, b) => a - b)升序 
* concat()连接
* slice(start,end) 复制,返回新数组,end负值为倒数
* splice(start,deletCount,item) 从start的位置开始删除deletCount个,并用item替换
* fill(value,start,end) start end 均为默认0,将value进行填充，返回this
* index0f(element,start) 返回索引值,未找到返回-1
* includes(searchElement)
* reduce:并归
* every/some返回true或false；filter返回true项组成的数组;map返回每次调用callback结果的数组;forEach无返回值;find找到第一个返回true的成员
* arr.entries() 键值对 arr.keys()键值 arr.values()值 这三个方法都返回一个新的Array Iterator对象，可以用for...of循环进行遍历


   

* 数组去重:
    `
        ES6:
        Array.prototype.unique = function() {
                return Array.from(new Set(this));
        }
        ES5：
             Array.prototype.unique = () => {
                 return this.filter((item,index) => this.indexOf(item) === index)
             }
        //indexOf 会遍历整个数组耗费性能
        Hash:
            Array.prototype.unique = function() {
            // n为hash表，r为临时数组
            var n = {}, r = [];
            for (var i = 0; i < this.length; i++) {
                // 如果hash表中没有当前项
                if (!n[this[i]]) {
                    // 存入hash表
                    n[this[i]] = true;
                    // 把当前数组的当前项push到临时数组里面
                    r.push(this[i]); 
                }
            }
            return r;
        }
    `
* 多维展开:
`   二维:
    (arr) => [].concat(...arr)
    多维判断:
    function flatten(arr){
        arr = (arr) => [].concat(...arr)
        return arr.some(Array.isArray)?flatten(arr):arr
    }
`
* 随机排序:
  function randomSort(arr){
      var newarr = arr || [];
      let random = Math.ceil(Math.random*arr.length)
      if (!arr.length) return newarr
      newarr.push(arr[random]);
      arr.splice(random,1)
      return randomSort(arr)  
  }
* 取最大值:
    数组归并:
    Array.prototype.Max = function() {return this.reduce((prev,next) => prev>next?prev:next)}
    Math方法:
    Array.prototype.Max = return Math.max(...this)//apply({},this)
* 
#### Dom操作:

## 其他问答

### JS问答:
* 谈谈This对象的理解:

`this总是指向函数的直接调用者（而非间接调用者）；
如果有new关键字，this指向new出来的那个对象；
在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；
`
* undifine和null: type of undifined =  undifine ; type if null = object
* use stric 禁用with  提高编译效率 

### 渲染机制
* Doctype:语法规则,定义xml或html的类型,浏览器会使用它来判断文档类型。h5:<!DOCTYPE html>4.01严格模式和宽松模式
* 浏览器渲染:HTML根据parse转成domtree,css根据parse转成styletree,然后结合,形成renderTree,layout计算属性,然后painting,显示。
* 运行机制:单线程,异步任务(定时器,dom事件,promise)
* eventLoop:先取同步队列中的函数,再取异步队列中的任务,以此循环
### 性能优化:

* 请减少HTTP请求,减少HTTP请求(雪碧图,懒加载)
* 异步加载:动态插入script,defer,html完成之后执行和加载顺序有关,async加载完立即执行,执行和加载顺序无关
* 标签标记为异步 <script src="async.js" async></script>
* 浏览器缓存：强缓存和协商缓存  
`
 强缓存:可直接使用
 expires:绝对时间
 cache-contorl: 相对过期时间 max-age = xxx

 协商缓存:与服务器通信确定过期时间:
 Last-MOdified(服务器返回最后一次修改时间) if-Modifined-since(通知服务器所请求资源的最后一次修改时间,服务器进行对比,若没改过则缓存) 
 Etag(服务器返回哈希值) if-None-Match(通知服务器最后一次的哈希值,由服务器进行对比)
`
* cdn(反向代理) ,压缩css和js,还有图片,Gzip压缩
* DNS预解析,meta标签里设置 <link rel = "dns-prefetch"></link> <meta> http-equiv = "x-dns-prefect-contorl"</meta>(打开https中的a标签预解析)    
* 不使用@import
* 减少作用域链查找即局部变量
* 重绘,外观改变,重排计算宽高,回炉重造 使用class减少dom操作
* 减少重定向
* 文件外部引用,css头,js尾部
* 工具Google PageSpeed
* CommonsChunkPlugin打包相同代码
#### React

* 按需加载：使用webpack, require.ensure() 在代码中设置了切割点(require)之后,webpack会分开打包,
`
 getComponent={(location, callback) => {
    require.ensure([], require => {
      callback(null, require('./PermalinkedComment'))
    }, 'PermalinkedComment')
  }}
`
* 预加载:link标签中 添加 as = "script" 
* 插件,react-layz-load 图片
* setState:`
    setState的时候先进行一个判断看是不是在batchUpdate中,如果在先保存在dirtyComponents中,如果不在遍历所有的dirtyComponents然后调用updateComponent来更新
`
* Redux: 使用Store存储数据,定义store时需要传入reducer,store可以有一个subscribe订阅状态变化,通过action定义数据的type,然后通过dispatch发送到ruducer进行处理,reducer接受action和state然后根据action的type进行处理之后返回新的state。
redux异步可以使用中间件redux-thunk,在action中先处理异步请求,让你得到你想要的数据,然后在fetch的then里面dispatch
#### 安全问题
* CSRF:跨站请求伪造:登录过会保存cookie,引诱点击,携带cokkie访问,误认为是合法用户,自动执行接口
* 解决办法:手动携带token,refer验证,验证页面来源
* XSS：跨域脚本攻击 : 注入脚本
* 防御:
#### 错误分类
* 即时运行错误
* try..catch
* window.onerror
* 资源加载错误
* object.onerror
* performance.getEntries()已加载资源
* ERROR事件捕获
* 跨域错误:错误类型:scriptError,还需要解决跨域CROS
* 上报错误,img.src地址直接传递
#### JQ
* 添加插件 $.FN.xxx = function(){}
* 常用模板 templet.js hogan.js ejs模板引擎
* 事件委托

#### Git
* $ git reset --hard 某个版本号  

#### ES6常用:
* 字符串模板
* 箭头函数
* assign({},Object,{key:Value})
* promise
* 默认参数
* let,const
* 解构赋值
* 展开运算符
* class
* import
#### 简单算法:
* 快速排序:
`function quickSort(arr) {
    if (arr.length <= 1) return arr;
    var mid = Math.floor(arr.length/2);
    var midel = arr.splice(mid,1)[0];
    var left = [];
    var right = [];
    arr.forEach(
    (item,index,_arr) =>{
        item<midel?left.push(item):right.push(item)
    }
    )
    return quickSort(left).concat([midel],quickSort(right))
}`
### React
* 生命周期:getDefaultProps,getInitialstate,componentWillMount,render,componentDidMount,存在期:componentwillreceiveProps,shouldComponentUpdate,componentWillUpdate,销毁:componentwillUnmount
* 无状态组件:没有state
* react表单处理:推荐双向绑定,提交state中的值,通过ajax模拟form表单
* formToObject.js

#### 问答准备:
* 遇到的难点:
`
我（最近的一个时间）在做（怎样的一个产品／程序），这个产品／程序的目的是（帮助用户完成什么事），其中有一个（什么模块），为了实现（什么功能），用到了（什么技术），但是（遇到了什么挑战／难点／bug），我通过（怎样的手段）定位问题所在，问题出现的原因是（简要的点到技术点的描述），我在（至少两个资料来源）上找到了参考，最后基于（怎样的决策标准）决定采用（何种解决方法），运用了（哪种技术），最后成功解决了问题／实现了功能，结果是这个产品／程序（对用户，系统，性能，可用性，资源等产生了何种正面的影响）。下一步，我认为我应该研究（何种更先进的方式），进一步（怎样让产品／程序做得更好）。

`
* 遇到的问题,我上次在用react做一个游戏平台的移动端,其中有一个游戏展示的模块,这个模块就是根据后台发来的数据,展示游戏的主要内容,可以实现,打分,收藏,评论等功能,那就这个展示嘛,肯定要把数据用map循环出来,就要很多个li嘛,而且用了懒加载,数据异步加载,下拉添加到循环列表里,测试了几下,点击,评论什么的,都没发现什么问题,后来就一直下拉下拉下拉,哎,我就发现,拉的次数多了之后,响应好像就变慢了,然后我就取消了懒加载,测了下,还真的是,有500+数据,也就是上千元素的时候,事件响应特别慢,我就取消了这个点击事件,哎不卡了,原来是这个事件更改了state,但是我就想,react不是虚拟dom嘛,他不会重新全部渲染啊,为什么会有这种奇怪的问题,我先是用针对性的写了shouldComponentUpdate,用了Immutable和React.addons.PureRenderMixin,发现根本没用,就想办法嘛,然后一开始就想,我就认为控制元素的数量,也就是这个数据的条数,我想是给他加载3屏,就像无缝轮播图那样,上翻下翻都没问题,但其实到顶和底的时候都重新刷新页面的数据,数据总是3屏,然后这么做了之后发现一个问题,用户体验差,拉到底就不说了有个loading,拉倒顶的时候就闪烁,延迟,我又想了个办法,就是把他们都存起来,设个计数器,到底+1,到顶-1,不需要总是请求,直接根据计数去拿数组里的某一段,然后发现,如果滚的很快,还是..会卡,没办法就又去谷歌,翻文档,终于发现这个问题,原来是这个只要state改变,render就触发,虽然是虚拟dom,不会整个真实dom都改变,但是,他diff虚拟dom树对比的这个过程,是非常耗时的,shouldcomponent没用的原因也就是因为这个不是因为无效渲染慢,而是diff慢,卡是卡在这了,我也和我们同伴讨论过这个问题,他的意见是,让我重新设计下组件,评分,评论
### Vue 
* vue与React区别:react虚拟dom,数据不可变,通过diff来计算,而vu数据可变,数据变更直接发出更新。JSX不够直观,亲自Dom控制复杂,比如说动画。
* 特点:简洁,轻量,数据驱动,组件化
* css scoped 只在当前组件中起作用
* beforeCreate create beforeMount Mounted beforeUpdate update beforeDestory destory
### 8月11日面:
* JS实现依赖注入:
  `
  xxx...
  `
* 一道算法题：给出数字N,显示所有大于0的整数相加等于N的序列;
### 8月14日面:
* JSX解析过程
* promise三种状态,pending,resolve,reject
* immutable.js原理:
`
 immutable.js他可以创建 不可变数据类型List,Map,(fromJS方法),任何操作都会会返回新的对象。Structural Sharing 结构共享,用hash链表,添加一个新结点把旧结点的父子关系转移到新结点上，不需要改所有节点,就是共享相同的部分,达到性能提升。Immutable.is方法;缺点,引用库,还不小,类型转换繁琐,第三方组件,入侵性强；pureRenderMixxin浅比较,数据结构复杂的话,会有多余的diff过程。

`
* diff算法:    
  `
    比较之前虚拟树和之后虚拟树两个树结构的变动,react进行了优化,因为html里很少有组件被移到树种的不同级别,所以就使用一级一级的去对树进行比较,然后提高性能。      
    还有就是key,我们循环的时候必须添加key值,原因就是相同的组件,插入,或者移出列表中的一个,或者位置变换,这个时候就用到key,标记兄弟元素,diff的时候如果有key,就会原虚拟树中横向比较,就能发现相同的,就避免了不必要操作,提高了性能     
    组件的比较:diff算法只比较有相同类的组件.
    事件代理:事件绑定dom很耗内存,所以使用了事件代理,然后为每个事件和事件监听创建了一个对象,都放在HashMap中储存,这样提高性能。
    只要setstate,标记为dirty,事件结束,就会找到所有被标记dirty的然后渲染,setState调用时,组件会重新diff虚拟dom,例如在app组件中,会影响全部的子,所以要避免,也可以通过shouldComponentWillMount()
  `
* 闭包(重点):定义在一个函数内的函数,这个函数保持了对父级作用域中变量的引用,就形成了闭包;
* 闭包的使用:需要保存一个变量,又不想放在全局之中污染全局,就可以使用一个闭包,引用一下这个变量,这样这个变量就被保存下来了
* 浅拷贝与深拷贝:值拷贝(堆),引用拷贝(栈)
* sass
* fetch
* amd标准(定义引用),requireJS(解决问题,模块化,依赖,按需加载)
* 如何避免回调地狱 promise 监听事件
* 123 instance0f(String) false  
* 安全问题,网络攻击
* 优化图片加载的方式:cdn,多域名储存(提高并发),放弃cookie传输
* JQ的问题...？？？
* js语言的缺点
* http新标准
* 域名收敛:即减少资源域名的数量;域名发散是pc端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。
* 首屏时间的计算,两种情况:
A：SPA应用,html开头打点,css文件加载打点,html内容加载完毕打点,js文件加载打点,ajax请求打点,渲染内容打点 渲染内容打点剪掉开头点 基本等于加载时间
B:服务端渲染应用:html开头,css文件加载,返回的html已经解析完成,js文件加载前打点，点4-点1
*此处注意:css加载并行,但会阻塞执行*
* 
# Node.js 
* Buffer:用于处理2进制,比如文件,tcp流
* stream：是一个抽象接口,可以读写,然后有事件,控制开始和结束