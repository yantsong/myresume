# 面试整理

## HTML/css
#### 盒模型
* 内容(content)、填充(padding)、边界(margin)、 边框(border).
* IE内容包含了border和padding

####  CSS3/HTML5新特性
* 常见meta标签
`
    页面关键词  <meta name="keywords" content="your tags" />
    页面描述    <meta name="description" content="150 words" />
    webapp全屏模式 <meta name="apple-mobile-web-app-capable" content="yes" />
    申明编码 <meta charset='utf-8' />
    优先使用 IE 最新版本和 Chrome
　　<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

`
* css3新特性:
    border-radius background-size border-image  linear渐变 transfrom2d 3d旋转缩放  transition
* H5 新特性:
    localStorage(长期) sessionStorage(浏览器关闭) querySelector getElementsByClassName classList -add() -remove flex 新语义标签 article section figure
    

## Css细节问题



## JS
#### 基础问题
* 基本数据类型 undefined null string  number boolean
* 引用数据类型 function object array
* 其他内置对象 Function、Argument、Math、Date、RegExp、Error
* JS堆和栈: 
    栈：原始数据类型（Undefined，Null，Boolean，Number，String）  
    堆：引用数据类型（对象、数组、函数）
* call:call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。  (如果不指定为全局即window
####原型以及原型链
    * JavaScript中任意对象都有一个内置属性[[prototype]]即_proto_, _proto_指向创建这个对象的函数(constructor)的prototype
    * 每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。而函数也是对象所以也有_proto_
    * 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就通过_proto_去prototype里找这个属性，这个prototype又会有自己的_proto_又指向它构造函数的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。
    * 继承: 
        `
           完美:
                function Parent(name) {
                    this.name = name;
                }

                Parent.prototype.play = function() {
                    console.log(this.name);
                }


                function Child(name, age) {
                    Parent.call(this, name);
                    this.age = age;
                }
                //通过原型链来实现原型属性和方法的继承
                Child.prototype = Object.create(Parent.prototype);

                // 多态
                Child.prototype.play = function() {
                    //借用父对象构造函数
                    Parent.prototype.play.call(this);
                    console.log(this.age);
                }
                //这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。
                var child = new Child();
        
        `
        * new之后发生的事情
        `
            (1)创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
            (2)属性和方法被加入到 this 引用的对象中。
            (3)新创建的对象由 this 所引用，并且最后隐式的返回 this 。
            //
            var base = new Base();
            var obj = {};
            obj.__proto__ = Base.prototype;
            Base.call(obj);
        
        `


#### ajax 
   * json与字符串的转化:
   JSON.parse(data)//json字符串变对象
   JSON.stringfiy//对象转成序列化字符串

   * ajax: new - open(参数) -onload(200&&400) - error - send
    `
         var request = new XMLHttpRequest();
        request.open('GET', '/my/url', true);

        request.onload = function() {
        if (request.status >= 200 && request.status < 400) {
            // Success!
            var data = JSON.parse(request.responseText);
        } else {
            // We reached our target server, but it returned an error

        }
        };

        request.onerror = function() {
        // There was a connection error of some sort
        };

        request.send();
    `
    * ajax post: new open(post) setRequestHeader('content-type',applocation/x-www-form-urlencoded) --onload --send(data)

#### fetch
    自带promise,fetch(
        url,{
            method:'',headers:{'content-type':'xxxx'},body:''
        }).then().then(function(data){}).catch
#### 数组操作:
* 重要的数组操作



* 数组去重:
    `
        ES6:
        Array.prototype.unique = function() {
                return Array.from(new Set(this));
        }
        ES5：
             Array.prototype.unique = () => {
                 return this.filter((item,index) => this.indexOf(item) === index)
             }
        //indexOf 会遍历整个数组耗费性能
        Hash:
                Array.prototype.unique = function() {
            // n为hash表，r为临时数组
            var n = {}, r = [];
            for (var i = 0; i < this.length; i++) {
                // 如果hash表中没有当前项
                if (!n[this[i]]) {
                    // 存入hash表
                    n[this[i]] = true;
                    // 把当前数组的当前项push到临时数组里面
                    r.push(this[i]); 
                }
            }
            return r;
        }
    `

## 其他问答
#### JQ
* 添加插件 $.FN.xxx = function(){}
#### Git
    * $ git reset --hard 某个版本号